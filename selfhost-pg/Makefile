# PostgreSQL Production Management Makefile
# Usage: make help

.PHONY: help start stop restart status backup monitor security health logs clean firewall-status firewall-open-all firewall-allow firewall-close firewall-local

# Default target
help: ## Show this help message
	@echo "PostgreSQL Production Management Commands:"
	@echo ""
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}; {printf "  \033[36m%-20s\033[0m %s\n", $$1, $$2}'

# Environment setup
check-env: ## Check if environment is properly configured
	@if [ ! -f .env ]; then \
		echo "‚ùå .env file not found. Copy .env.template to .env and configure it."; \
		exit 1; \
	fi
	@echo "‚úÖ Environment configuration found"

# Production services
start: check-env ## Start production services
	@echo "üöÄ Starting production PostgreSQL services..."
	docker compose -f docker-compose.prod.yml up -d
	@echo "‚úÖ Services started successfully"
	@make status

stop: ## Stop all services
	@echo "üõë Stopping services..."
	docker compose -f docker-compose.prod.yml down
	@echo "‚úÖ Services stopped"

restart: ## Restart all services
	@echo "üîÑ Restarting services..."
	docker compose -f docker-compose.prod.yml down
	docker compose -f docker-compose.prod.yml up -d
	@echo "‚úÖ Services restarted"

status: ## Show service status
	@echo "üìä Service Status:"
	@docker compose -f docker-compose.prod.yml ps

# Development services (fallback to regular compose)
dev-start: check-env ## Start development services
	@echo "üîß Starting development services..."
	docker compose up -d
	@echo "‚úÖ Development services started"

dev-stop: ## Stop development services
	@echo "üõë Stopping development services..."
	docker compose down

# Database operations
backup: ## Create database backup
	@echo "üíæ Creating database backup..."
	./scripts/backup.sh
	@echo "‚úÖ Backup completed"

restore: ## Restore database from backup (requires BACKUP_FILE variable)
	@if [ -z "$(BACKUP_FILE)" ]; then \
		echo "‚ùå Please specify BACKUP_FILE=path/to/backup.sql.gz"; \
		exit 1; \
	fi
	@echo "üì• Restoring database from $(BACKUP_FILE)..."
	@if [ -f "$(BACKUP_FILE)" ]; then \
		zcat "$(BACKUP_FILE)" | docker exec -i postgres_primary psql -U postgres_admin -d production_db; \
		echo "‚úÖ Database restored successfully"; \
	else \
		echo "‚ùå Backup file not found: $(BACKUP_FILE)"; \
		exit 1; \
	fi

# Monitoring and maintenance
monitor: ## Run health monitoring
	@echo "üîç Running health check..."
	./scripts/monitor.sh

security: ## Run security audit
	@echo "üîí Running security audit..."
	./scripts/security-audit.sh

health: ## Quick health check
	@echo "‚ù§Ô∏è  Quick Health Check:"
	@docker exec postgres_primary pg_isready -U postgres_admin -d production_db && echo "‚úÖ Database is healthy" || echo "‚ùå Database is not responding"
	@docker exec pgadmin_web wget --quiet --tries=1 --spider http://localhost/misc/ping && echo "‚úÖ pgAdmin is healthy" || echo "‚ùå pgAdmin is not responding"

# Logs and debugging
logs: ## Show service logs
	@echo "üìã Service Logs:"
	docker compose -f docker-compose.prod.yml logs --tail=50

logs-follow: ## Follow service logs in real-time
	@echo "üìã Following logs (Ctrl+C to stop)..."
	docker compose -f docker-compose.prod.yml logs -f

logs-db: ## Show database logs only
	@echo "üóÉÔ∏è Database Logs:"
	docker compose -f docker-compose.prod.yml logs database --tail=50

logs-pgadmin: ## Show pgAdmin logs only  
	@echo "üåê pgAdmin Logs:"
	docker compose -f docker-compose.prod.yml logs pgladmin --tail=50

# Database connection
connect: ## Connect to database via psql
	@echo "üîó Connecting to database..."
	docker exec -it postgres_primary psql -U postgres_admin -d production_db

connect-readonly: ## Connect as readonly user
	@echo "üîó Connecting as readonly user..."
	docker exec -it postgres_primary psql -U readonly_user -d production_db

# Maintenance operations
vacuum: ## Run database vacuum (maintenance)
	@echo "üßπ Running database vacuum..."
	docker exec postgres_primary psql -U postgres_admin -d production_db -c "VACUUM ANALYZE;"
	@echo "‚úÖ Vacuum completed"

reindex: ## Reindex database
	@echo "üìä Reindexing database..."
	docker exec postgres_primary psql -U postgres_admin -d production_db -c "REINDEX DATABASE production_db;"
	@echo "‚úÖ Reindex completed"

stats: ## Show database statistics
	@echo "üìà Database Statistics:"
	@docker exec postgres_primary psql -U postgres_admin -d production_db -c "\
		SELECT schemaname, tablename, n_tup_ins as inserts, n_tup_upd as updates, n_tup_del as deletes \
		FROM pg_stat_user_tables ORDER BY n_tup_ins DESC LIMIT 10;"

# Cleanup operations
clean-logs: ## Clean old log files
	@echo "üßπ Cleaning old logs..."
	find logs/ -name "*.log" -mtime +7 -delete 2>/dev/null || true
	find logs/ -name "security_report_*.txt" -mtime +30 -delete 2>/dev/null || true
	@echo "‚úÖ Logs cleaned"

clean-backups: ## Clean old backups (keeps last 30 days)
	@echo "üßπ Cleaning old backups..."
	find backups/ -name "full_backup_*.sql*" -mtime +30 -delete 2>/dev/null || true
	find backups/ -name "config_backup_*.tar.gz" -mtime +30 -delete 2>/dev/null || true
	@echo "‚úÖ Old backups cleaned"

clean-all: clean-logs clean-backups ## Clean all temporary files

# Security operations
update-passwords: ## Update database passwords (interactive)
	@echo "üîí Password Update Process:"
	@echo "This will guide you through updating database passwords..."
	@./scripts/update-passwords.sh

ssl-setup: ## Setup SSL certificates
	@echo "üîê SSL Certificate Setup:"
	@echo "Place your SSL certificates in the ssl/ directory"
	@echo "Required files: server.crt, server.key, ca.crt"
	@mkdir -p ssl/
	@ls -la ssl/ 2>/dev/null || echo "SSL directory created. Add your certificates."

# Disaster recovery
emergency-stop: ## Emergency stop all services
	@echo "üö® EMERGENCY STOP - Forcing container shutdown..."
	docker kill postgres_primary pgladmin_web 2>/dev/null || true
	docker compose -f docker-compose.prod.yml down --remove-orphans
	@echo "‚úÖ Emergency stop completed"

reset-pgladmin: ## Reset pgAdmin (clears settings and passwords)
	@echo "üîÑ Resetting pgAdmin..."
	docker compose -f docker-compose.prod.yml stop pgladmin
	docker compose -f docker-compose.prod.yml rm -f pgladmin  
	docker volume rm selfhostpg_pgladmin_data 2>/dev/null || true
	docker compose -f docker-compose.prod.yml up pgladmin -d
	@echo "‚úÖ pgAdmin reset completed"

# Information
version: ## Show versions of all components
	@echo "üìã Component Versions:"
	@echo "PostgreSQL: $$(docker exec postgres_primary psql -U postgres_admin -d production_db -t -c 'SELECT version();' 2>/dev/null | head -1 || echo 'Not running')"
	@echo "Docker Compose: $$(docker compose --version)"
	@echo "Docker: $$(docker --version)"

info: ## Show system information  
	@echo "‚ÑπÔ∏è  System Information:"
	@echo "Containers: $$(docker ps --format 'table {{.Names}}\t{{.Status}}' | grep -E '(postgres|pgladmin)')"
	@echo "Volumes: $$(docker volume ls --format 'table {{.Name}}' | grep selfhostpg)"
	@echo "Networks: $$(docker network ls --format 'table {{.Name}}' | grep selfhostpg)"
	@echo "Disk Usage: $$(du -sh backups/ logs/ 2>/dev/null || echo 'No data directories')"

# Firewall management
firewall-status: ## Show firewall rules for database & pgAdmin ports
	@./scripts/firewall.sh status

firewall-open-all: ## Allow all sources to access PostgreSQL & pgAdmin ports
	@./scripts/firewall.sh allow-all

firewall-allow: ## Allow only specific IPs (usage: make firewall-allow IPS="1.2.3.4 5.6.7.8")
	@if [ -z "$(IPS)" ]; then echo "‚ùå Please provide IPS=\"IP1 IP2\""; exit 1; fi; \
	./scripts/firewall.sh allow --ips "$(IPS)"

firewall-close: ## Remove all selfhost-pg firewall rules for these ports
	@./scripts/firewall.sh close

firewall-local: ## Restrict access to localhost only (loopback)
	@./scripts/firewall.sh allow-local
